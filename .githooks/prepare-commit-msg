#!/usr/bin/env bash
set -euo pipefail

# Git hook: prepare-commit-msg
# 逻辑：
# 1) 若提交信息为空（去除注释与空白），先填充为 "update" 占位；
# 2) 若内容为 "update"（或仍为空），尝试调用生成器生成提交信息；
# 3) 若生成失败，保留为 "update"。

MSG_FILE="$1"
COMMIT_SOURCE="${2:-}"
SHA1="${3:-}"

# 跳过合并/压缩提交
case "$COMMIT_SOURCE" in
  merge|squash) exit 0 ;;
esac

# 统一编码、语言
export PYTHONUTF8=1
export PYTHONIOENCODING=UTF-8
export LC_ALL="${LC_ALL:-C.UTF-8}"
export LANG="${LANG:-C.UTF-8}"
export COMMIT_MSG_LANG=zh

# 透传可用的 Google/Gemini API Key（可为空）
export GEMINI_API_KEY="${GEMINI_API_KEY-}"
export GOOGLE_API_KEY="${GOOGLE_API_KEY-}"
export GOOGLEAI_API_KEY="${GOOGLEAI_API_KEY-}"

sanitize() { sed '/^#/d' "$1" 2>/dev/null | tr -d '\r' | sed 's/^[[:space:]]\+//;s/[[:space:]]\+$//'; }

# 读取并预处理内容
CONTENT=""
if [[ -f "$MSG_FILE" ]]; then
  CONTENT="$(sanitize "$MSG_FILE")" || CONTENT=""
fi

# 步骤 1：空白 -> 先写入占位 "update"
if [[ -z "$CONTENT" ]]; then
  printf '%s\n' "update" > "$MSG_FILE"
  CONTENT="update"
fi

shopt -s nocasematch || true
NEED_GEN=0
if [[ -z "$CONTENT" || "$CONTENT" == "update" ]]; then
  NEED_GEN=1
fi
shopt -u nocasematch || true

if [[ $NEED_GEN -eq 1 ]]; then
  REPO_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
  SCRIPT_PATH="$REPO_ROOT/my_scripts/gen_commit_msg_googleai.py"

  if [[ -f "$SCRIPT_PATH" ]]; then
    # 选择 python 解释器，优先本地虚拟环境
    if [[ -x "$REPO_ROOT/.venv/Scripts/python.exe" ]]; then
      PY="$REPO_ROOT/.venv/Scripts/python.exe"
    elif [[ -x "$REPO_ROOT/.venv/bin/python" ]]; then
      PY="$REPO_ROOT/.venv/bin/python"
    elif command -v python3 >/dev/null 2>&1; then
      PY=python3
    elif command -v python >/dev/null 2>&1; then
      PY=python
    elif command -v py >/dev/null 2>&1; then
      PY="py -3"
    else
      PY=""
    fi

    if [[ -n "$PY" ]]; then
      if [[ "${COMMIT_MSG_DEBUG:-0}" == "1" ]]; then
        OUT=$($PY "$SCRIPT_PATH" || true)
      else
        OUT=$($PY "$SCRIPT_PATH" 2>/dev/null || true)
      fi
      OUT_TRIM="$(printf '%s' "$OUT" | sed 's/^[[:space:]]\+//;s/[[:space:]]\+$//')"
      if [[ -n "$OUT_TRIM" ]]; then
        printf '%s\n' "$OUT_TRIM" > "$MSG_FILE"
      fi
    fi
  fi

  # 生成后校验：若仍为空，则保留占位
  CONTENT_NEW="$(sanitize "$MSG_FILE")"
  if [[ -z "$CONTENT_NEW" ]]; then
    printf '%s\n' "update" > "$MSG_FILE"
  fi
fi

exit 0

